{"version":3,"file":"main.js","mappings":"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","sources":["webpack://react-indexed-db/webpack/bootstrap","webpack://react-indexed-db/webpack/runtime/compat get default export","webpack://react-indexed-db/webpack/runtime/define property getters","webpack://react-indexed-db/webpack/runtime/hasOwnProperty shorthand","webpack://react-indexed-db/webpack/runtime/make namespace object","webpack://react-indexed-db/external commonjs \"react\"","webpack://react-indexed-db/./src/Utils.ts","webpack://react-indexed-db/./src/createDatabaseTransaction.ts","webpack://react-indexed-db/./src/createReadwriteTransaction.ts","webpack://react-indexed-db/./src/createReadonlyTransaction.ts","webpack://react-indexed-db/./src/indexed-db.ts","webpack://react-indexed-db/./src/indexed-context.tsx","webpack://react-indexed-db/./src/indexed-hooks.ts"],"sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"react\");","export interface Options {\n  storeName: string;\n  dbMode: IDBTransactionMode;\n  error: (e: Event) => any;\n  complete: (e: Event) => any;\n  abort?: any;\n}\n\nexport function validateStoreName(db: IDBDatabase, storeName: string) {\n  return db.objectStoreNames.contains(storeName);\n}\n\nexport function validateBeforeTransaction(\n  db: IDBDatabase,\n  storeName: string,\n  reject: (errorMessage: string) => void,\n) {\n  if (!db) {\n    reject(\n      \"You need to use the openDatabase function to create a database before you query it!\",\n    );\n  }\n  if (!validateStoreName(db, storeName)) {\n    reject(`objectStore does not exists: ${storeName}`);\n  }\n}\n\nexport function createTransaction(\n  db: IDBDatabase,\n  options: Options,\n): IDBTransaction {\n  const trans: IDBTransaction = db.transaction(\n    options.storeName,\n    options.dbMode,\n  );\n  trans.onerror = options.error;\n  trans.oncomplete = options.complete;\n  trans.onabort = options.abort;\n  return trans;\n}\n\nexport function optionsGenerator(\n  type: any,\n  storeName: any,\n  reject: (e: Event) => void,\n  resolve: (e?: Event) => void,\n): Options {\n  return {\n    storeName: storeName,\n    dbMode: type,\n    error: (e: Event) => {\n      reject(e);\n    },\n    complete: () => {\n      resolve();\n    },\n    abort: (e: Event) => {\n      reject(e);\n    },\n  };\n}\n\n// export function* processRequest({ request, success, error }: any) {\n//   request.onerror = function(event: Event) {\n//     error(error);\n//     yield error;\n//   };\n//   request.onsuccess = function(evt: Event) {\n//     let cursor: IDBCursorWithValue = (<IDBRequest>evt.target).result;\n//     if (cursor) {\n//       result.push(cursor.value);\n//       cursor.continue();\n//     } else {\n//       resolve(result);\n//     }\n//   };\n// }\n","import {\n  createTransaction as defaultCreateTransaction,\n  optionsGenerator as defaultOptionsBuilder,\n} from \"./Utils\";\nimport { DBMode } from \"./indexed-db\";\n\nexport function createDatabaseTransaction(\n  database: IDBDatabase,\n  mode: DBMode,\n  storeName: string,\n  resolve: (e?: Event) => void,\n  reject: (e: Event) => void,\n  createTransaction: typeof defaultCreateTransaction = defaultCreateTransaction,\n  buildOptions: typeof defaultOptionsBuilder = defaultOptionsBuilder,\n) {\n  const options = buildOptions(mode, storeName, reject, resolve);\n  const transaction: IDBTransaction = createTransaction(database, options);\n  const store = transaction.objectStore(storeName);\n\n  return {\n    store,\n    transaction,\n  };\n}\n","import { DBMode } from \"./indexed-db\";\nimport { createDatabaseTransaction } from \"./createDatabaseTransaction\";\n\nexport function createReadwriteTransaction(\n  database: IDBDatabase,\n  store: string,\n  resolve: (e?: any) => void,\n  reject: (e: Event) => void,\n) {\n  return createDatabaseTransaction(\n    database,\n    DBMode.readwrite,\n    store,\n    resolve,\n    reject,\n  );\n}\n","import { DBMode } from \"./indexed-db\";\nimport { createDatabaseTransaction } from \"./createDatabaseTransaction\";\n\nexport function createReadonlyTransaction(\n  database: IDBDatabase,\n  store: string,\n  resolve: (payload?: any) => void,\n  reject: (e: Event) => void,\n) {\n  return createDatabaseTransaction(\n    database,\n    DBMode.readonly,\n    store,\n    resolve,\n    reject,\n  );\n}\n","import { validateBeforeTransaction } from \"./Utils\";\nimport { ObjectStoreMeta, ObjectStoreSchema } from \"./indexed-hooks\";\nimport { createReadwriteTransaction } from \"./createReadwriteTransaction\";\nimport { createReadonlyTransaction } from \"./createReadonlyTransaction\";\n\nexport type Key =\n  | string\n  | number\n  | Date\n  | ArrayBufferView\n  | ArrayBuffer\n  | IDBKeyRange; // IDBArrayKey\nexport interface IndexDetails {\n  indexName: string;\n  order: string;\n}\nconst indexedDB: Partial<IDBFactory> =\n  typeof window === \"undefined\" ? \n  {} : (\n    window.indexedDB ||\n    (<any>window).mozIndexedDB ||\n    (<any>window).webkitIndexedDB ||\n    (<any>window).msIndexedDB\n  );\n\nexport function openDatabase(\n  dbName: string,\n  version: number,\n  upgradeCallback?: (e: Event, db: IDBDatabase) => void,\n) {\n  return new Promise<IDBDatabase>((resolve, reject) => {\n    if (!Object.keys(indexedDB)) {\n      reject(\"IndexedDB not supported in this environment\");\n    }\n    const request = indexedDB?.open(dbName, version);\n    let db: IDBDatabase;\n    request.onsuccess = () => {\n      db = request.result;\n      resolve(db);\n    };\n    request.onerror = () => {\n      reject(`IndexedDB error: ${request.error}`);\n    };\n    if (typeof upgradeCallback === \"function\") {\n      request.onupgradeneeded = (event: Event) => {\n        upgradeCallback(event, db);\n      };\n    }\n  });\n}\n\nexport function CreateObjectStore(\n  dbName: string,\n  version: number,\n  storeSchemas: ObjectStoreMeta[],\n) {\n  if (!Object.keys(indexedDB)) {\n    throw new Error(\"IndexedDB not supported in this environment\");\n  }\n  const request: IDBOpenDBRequest = indexedDB?.open(dbName, version);\n\n  request.onupgradeneeded = function (event: IDBVersionChangeEvent) {\n    const database: IDBDatabase = (event.target as any).result;\n    storeSchemas.forEach((storeSchema: ObjectStoreMeta) => {\n      if (!database.objectStoreNames.contains(storeSchema.store)) {\n        const objectStore = database.createObjectStore(\n          storeSchema.store,\n          storeSchema.storeConfig,\n        );\n        storeSchema.storeSchema.forEach((schema: ObjectStoreSchema) => {\n          objectStore.createIndex(schema.name, schema.keypath, schema.options);\n        });\n      }\n    });\n    database.close();\n  };\n  request.onsuccess = function (e: any) {\n    e.target.result.close();\n  };\n}\n\nexport function DBOperations(\n  dbName: string,\n  version: number,\n  currentStore: string,\n) {\n  // Readonly operations\n  const getAll = <T>() =>\n    new Promise<T[]>((resolve, reject) => {\n      openDatabase(dbName, version).then((db) => {\n        validateBeforeTransaction(db, currentStore, reject);\n        const { store } = createReadonlyTransaction(\n          db,\n          currentStore,\n          resolve,\n          reject,\n        );\n        const request = store.getAll();\n\n        request.onerror = (error) => reject(error);\n\n        request.onsuccess = function ({ target: { result } }: any) {\n          resolve(result as T[]);\n        };\n      });\n    });\n\n  const getByID = <T>(id: string | number) =>\n    new Promise<T>((resolve, reject) => {\n      openDatabase(dbName, version).then((db: IDBDatabase) => {\n        validateBeforeTransaction(db, currentStore, reject);\n        const { store } = createReadonlyTransaction(\n          db,\n          currentStore,\n          resolve,\n          reject,\n        );\n        const request = store.get(id);\n\n        request.onsuccess = function (event: Event) {\n          resolve((event.target as any).result as T);\n        };\n      });\n    });\n\n  const openCursor = (\n    cursorCallback: (event: Event) => void,\n    keyRange?: IDBKeyRange,\n  ) => {\n    return new Promise<void>((resolve, reject) => {\n      openDatabase(dbName, version).then((db) => {\n        validateBeforeTransaction(db, currentStore, reject);\n        const { store } = createReadonlyTransaction(\n          db,\n          currentStore,\n          resolve,\n          reject,\n        );\n        const request = store.openCursor(keyRange);\n\n        request.onsuccess = (event: Event) => {\n          cursorCallback(event);\n          resolve();\n        };\n      });\n    });\n  };\n\n  const getByIndex = (indexName: string, key: any) =>\n    new Promise<any>((resolve, reject) => {\n      openDatabase(dbName, version).then((db) => {\n        validateBeforeTransaction(db, currentStore, reject);\n        const { store } = createReadonlyTransaction(\n          db,\n          currentStore,\n          resolve,\n          reject,\n        );\n        const index = store.index(indexName);\n        const request = index.get(key);\n\n        request.onsuccess = (event: Event) => {\n          resolve((<IDBOpenDBRequest>event.target).result);\n        };\n      });\n    });\n\n  // Readwrite operations\n  const add = <T>(value: T, key?: any) =>\n    new Promise<number>((resolve, reject) => {\n      openDatabase(dbName, version).then((db) => {\n        const { store } = createReadwriteTransaction(\n          db,\n          currentStore,\n          resolve,\n          reject,\n        );\n        const request = store.add(value, key);\n\n        request.onsuccess = (evt: any) => {\n          key = evt.target.result;\n          resolve(key);\n        };\n\n        request.onerror = (error) => reject(error);\n      });\n    });\n\n  const update = <T>(value: T, key?: any) =>\n    new Promise<any>((resolve, reject) => {\n      openDatabase(dbName, version).then((db) => {\n        validateBeforeTransaction(db, currentStore, reject);\n        const { transaction, store } = createReadwriteTransaction(\n          db,\n          currentStore,\n          resolve,\n          reject,\n        );\n\n        transaction.oncomplete = (event) => resolve(event);\n\n        store.put(value, key);\n      });\n    });\n\n  const deleteRecord = (key: Key) =>\n    new Promise<any>((resolve, reject) => {\n      openDatabase(dbName, version).then((db) => {\n        validateBeforeTransaction(db, currentStore, reject);\n        const { store } = createReadwriteTransaction(\n          db,\n          currentStore,\n          resolve,\n          reject,\n        );\n        const request = store.delete(key);\n\n        request.onsuccess = (event) => resolve(event);\n      });\n    });\n\n  const clear = () =>\n    new Promise<void>((resolve, reject) => {\n      openDatabase(dbName, version).then((db) => {\n        validateBeforeTransaction(db, currentStore, reject);\n        const { store, transaction } = createReadwriteTransaction(\n          db,\n          currentStore,\n          resolve,\n          reject,\n        );\n\n        transaction.oncomplete = () => resolve();\n\n        store.clear();\n      });\n    });\n\n  return {\n    add,\n    getByID,\n    getAll,\n    update,\n    deleteRecord,\n    clear,\n    openCursor,\n    getByIndex,\n  };\n}\n\nexport enum DBMode {\n  readonly = \"readonly\",\n  readwrite = \"readwrite\",\n}\n","import React, { ReactNode } from \"react\";\nimport { DBOperations, openDatabase, Key } from \"./indexed-db\";\n\ninterface IndexedDBProps {\n  name: string;\n  version: number;\n  children: ReactNode;\n  objectStoresMeta: ObjectStoreMeta[];\n}\n\ninterface ObjectStoreMeta {\n  store: string;\n  storeConfig: { keyPath: string; autoIncrement: boolean; [key: string]: any };\n  storeSchema: ObjectStoreSchema[];\n}\n\ninterface ObjectStoreSchema {\n  name: string;\n  keypath: string;\n  options: { unique: boolean; [key: string]: any };\n}\n\nconst IndexedDBContext = React.createContext<{\n  db: any;\n  name: string;\n  version: number;\n}>({\n  db: null,\n  name: null,\n  version: null,\n});\n\nconst IndexedDBProvider = IndexedDBContext.Provider;\nconst IndexedDBCosumer = IndexedDBContext.Consumer;\n\nexport function IndexedDB({\n  name,\n  version,\n  children,\n  objectStoresMeta,\n}: IndexedDBProps) {\n  objectStoresMeta.forEach(async (schema: ObjectStoreMeta) => {\n    await openDatabase(name, version, (event: any) => {\n      const db: IDBDatabase = event.currentTarget.result;\n      const objectStore = db.createObjectStore(\n        schema.store,\n        schema.storeConfig,\n      );\n      schema.storeSchema.forEach((schema: ObjectStoreSchema) => {\n        objectStore.createIndex(schema.name, schema.keypath, schema.options);\n      });\n    });\n  });\n  return (\n    <IndexedDBProvider value={{ db: null, name, version }}>\n      {children}\n    </IndexedDBProvider>\n  );\n}\n\ninterface AccessDBProps {\n  children: ({\n    db,\n  }: {\n    db: IDBDatabase;\n    add: <T = any>(value: T, key?: any) => Promise<number>;\n    getByID: <T = any>(id: number | string) => Promise<T>;\n    getAll: <T = any>() => Promise<T[]>;\n    update: <T = any>(value: T, key?: any) => Promise<any>;\n    deleteRecord: (key: Key) => Promise<any>;\n    openCursor: (\n      cursorCallback: (event: Event) => void,\n      keyRange?: IDBKeyRange,\n    ) => Promise<void>;\n    getByIndex: (indexName: string, key: any) => Promise<any>;\n    clear: () => Promise<any>;\n  }) => ReactNode;\n  objectStore: string;\n}\n\nexport function AccessDB({ children, objectStore }: AccessDBProps) {\n  return (\n    <IndexedDBCosumer>\n      {(value) => {\n        const { db, name, version } = value;\n        // openDatabase(name, version);\n        return children({ db, ...DBOperations(name, version, objectStore) });\n      }}\n    </IndexedDBCosumer>\n  );\n}\n","import { useMemo } from \"react\";\nimport { DBOperations, Key, CreateObjectStore } from \"./indexed-db\";\n\nexport interface IndexedDBProps {\n  name: string;\n  version: number;\n  objectStoresMeta: ObjectStoreMeta[];\n}\n\nexport interface ObjectStoreMeta {\n  store: string;\n  storeConfig: { keyPath: string; autoIncrement: boolean; [key: string]: any };\n  storeSchema: ObjectStoreSchema[];\n}\n\nexport interface ObjectStoreSchema {\n  name: string;\n  keypath: string;\n  options: { unique: boolean; [key: string]: any };\n}\n\nexport interface useIndexedDB {\n  dbName: string;\n  version: number;\n  objectStore: string;\n}\n\nconst indexeddbConfiguration: { version: number; name: string } = {\n  version: null,\n  name: null,\n};\n\nexport function initDB({ name, version, objectStoresMeta }: IndexedDBProps) {\n  indexeddbConfiguration.name = name;\n  indexeddbConfiguration.version = version;\n  Object.freeze(indexeddbConfiguration);\n  CreateObjectStore(name, version, objectStoresMeta);\n}\n\nexport function useIndexedDB(objectStore: string): {\n  add: <T = any>(value: T, key?: any) => Promise<number>;\n  getByID: <T = any>(id: number | string) => Promise<T>;\n  getAll: <T = any>() => Promise<T[]>;\n  update: <T = any>(value: T, key?: any) => Promise<any>;\n  deleteRecord: (key: Key) => Promise<any>;\n  openCursor: (\n    cursorCallback: (event: Event) => void,\n    keyRange?: IDBKeyRange,\n  ) => Promise<void>;\n  getByIndex: (indexName: string, key: any) => Promise<any>;\n  clear: () => Promise<any>;\n} {\n  if (!indexeddbConfiguration.name || !indexeddbConfiguration.version) {\n    throw new Error(\"Please, initialize the DB before the use.\");\n  }\n  return useMemo(\n    () =>\n      DBOperations(\n        indexeddbConfiguration.name,\n        indexeddbConfiguration.version,\n        objectStore,\n      ),\n    [indexeddbConfiguration, objectStore],\n  );\n}\n"],"names":["__webpack_require__","module","getter","__esModule","d","a","exports","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","Symbol","toStringTag","value","require","validateBeforeTransaction","db","storeName","reject","objectStoreNames","contains","validateStoreName","options","trans","transaction","dbMode","onerror","error","oncomplete","complete","onabort","abort","optionsGenerator","type","resolve","e","createDatabaseTransaction","database","mode","createTransaction","buildOptions","store","objectStore","createReadwriteTransaction","DBMode","readwrite","createReadonlyTransaction","readonly","indexedDB","window","mozIndexedDB","webkitIndexedDB","msIndexedDB","openDatabase","dbName","version","upgradeCallback","Promise","keys","request","open","onsuccess","result","onupgradeneeded","event","DBOperations","currentStore","add","then","evt","target","getByID","id","getAll","update","put","deleteRecord","delete","clear","openCursor","cursorCallback","keyRange","getByIndex","indexName","index","IndexedDBContext","name","IndexedDBProvider","Provider","IndexedDBCosumer","Consumer","IndexedDB","children","forEach","schema","currentTarget","createObjectStore","storeConfig","storeSchema","createIndex","keypath","AccessDB","indexeddbConfiguration","initDB","objectStoresMeta","freeze","storeSchemas","Error","close","CreateObjectStore","useIndexedDB","useMemo"],"sourceRoot":""}